// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: clients.sql

package repository

import (
	"context"
	"database/sql"
)

const clientHasJobs = `-- name: ClientHasJobs :one
SELECT COUNT(*) > 0 FROM jobs WHERE client_id = ?
`

func (q *Queries) ClientHasJobs(ctx context.Context, clientID sql.NullString) (bool, error) {
	row := q.db.QueryRowContext(ctx, clientHasJobs, clientID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const countClients = `-- name: CountClients :one
SELECT COUNT(*) FROM clients
WHERE (?1 = '' OR name LIKE '%' || ?1 || '%' OR company LIKE '%' || ?1 || '%')
`

func (q *Queries) CountClients(ctx context.Context, search interface{}) (int64, error) {
	row := q.db.QueryRowContext(ctx, countClients, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createClient = `-- name: CreateClient :one
INSERT INTO clients (id, name, company, email, phone, address, city, state, zip, tax_id, notes)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, company, email, phone, address, city, state, zip, tax_id, notes, created_at
`

type CreateClientParams struct {
	ID      string         `json:"id"`
	Name    string         `json:"name"`
	Company sql.NullString `json:"company"`
	Email   sql.NullString `json:"email"`
	Phone   sql.NullString `json:"phone"`
	Address sql.NullString `json:"address"`
	City    sql.NullString `json:"city"`
	State   sql.NullString `json:"state"`
	Zip     sql.NullString `json:"zip"`
	TaxID   sql.NullString `json:"tax_id"`
	Notes   sql.NullString `json:"notes"`
}

func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) (Client, error) {
	row := q.db.QueryRowContext(ctx, createClient,
		arg.ID,
		arg.Name,
		arg.Company,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.City,
		arg.State,
		arg.Zip,
		arg.TaxID,
		arg.Notes,
	)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Company,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.City,
		&i.State,
		&i.Zip,
		&i.TaxID,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const deleteClient = `-- name: DeleteClient :exec
DELETE FROM clients WHERE id = ?
`

func (q *Queries) DeleteClient(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteClient, id)
	return err
}

const getClient = `-- name: GetClient :one
SELECT id, name, company, email, phone, address, city, state, zip, tax_id, notes, created_at FROM clients WHERE id = ?
`

func (q *Queries) GetClient(ctx context.Context, id string) (Client, error) {
	row := q.db.QueryRowContext(ctx, getClient, id)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Company,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.City,
		&i.State,
		&i.Zip,
		&i.TaxID,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getClientByName = `-- name: GetClientByName :one
SELECT id, name, company, email, phone, address, city, state, zip, tax_id, notes, created_at FROM clients WHERE name = ?
`

func (q *Queries) GetClientByName(ctx context.Context, name string) (Client, error) {
	row := q.db.QueryRowContext(ctx, getClientByName, name)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Company,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.City,
		&i.State,
		&i.Zip,
		&i.TaxID,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const listClients = `-- name: ListClients :many
SELECT id, name, company, email, phone, address, city, state, zip, tax_id, notes, created_at FROM clients ORDER BY name ASC
`

func (q *Queries) ListClients(ctx context.Context) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, listClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Client{}
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Company,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.City,
			&i.State,
			&i.Zip,
			&i.TaxID,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientsPaginated = `-- name: ListClientsPaginated :many
SELECT id, name, company, email, phone, address, city, state, zip, tax_id, notes, created_at FROM clients
WHERE (?1 = '' OR name LIKE '%' || ?1 || '%' OR company LIKE '%' || ?1 || '%')
ORDER BY name ASC
LIMIT ?3 OFFSET ?2
`

type ListClientsPaginatedParams struct {
	Search interface{} `json:"search"`
	Offset int64       `json:"offset"`
	Limit  int64       `json:"limit"`
}

func (q *Queries) ListClientsPaginated(ctx context.Context, arg ListClientsPaginatedParams) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, listClientsPaginated, arg.Search, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Client{}
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Company,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.City,
			&i.State,
			&i.Zip,
			&i.TaxID,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClient = `-- name: UpdateClient :one
UPDATE clients SET
    name = ?,
    company = ?,
    email = ?,
    phone = ?,
    address = ?,
    city = ?,
    state = ?,
    zip = ?,
    tax_id = ?,
    notes = ?
WHERE id = ?
RETURNING id, name, company, email, phone, address, city, state, zip, tax_id, notes, created_at
`

type UpdateClientParams struct {
	Name    string         `json:"name"`
	Company sql.NullString `json:"company"`
	Email   sql.NullString `json:"email"`
	Phone   sql.NullString `json:"phone"`
	Address sql.NullString `json:"address"`
	City    sql.NullString `json:"city"`
	State   sql.NullString `json:"state"`
	Zip     sql.NullString `json:"zip"`
	TaxID   sql.NullString `json:"tax_id"`
	Notes   sql.NullString `json:"notes"`
	ID      string         `json:"id"`
}

func (q *Queries) UpdateClient(ctx context.Context, arg UpdateClientParams) (Client, error) {
	row := q.db.QueryRowContext(ctx, updateClient,
		arg.Name,
		arg.Company,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.City,
		arg.State,
		arg.Zip,
		arg.TaxID,
		arg.Notes,
		arg.ID,
	)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Company,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.City,
		&i.State,
		&i.Zip,
		&i.TaxID,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}
