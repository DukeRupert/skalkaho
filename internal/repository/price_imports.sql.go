// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: price_imports.sql

package repository

import (
	"context"
	"database/sql"
)

const bulkAutoApproveMatches = `-- name: BulkAutoApproveMatches :exec
UPDATE price_import_matches
SET status = 'auto_approved'
WHERE import_id = ? AND confidence >= ? AND status = 'pending'
`

type BulkAutoApproveMatchesParams struct {
	ImportID   string  `json:"import_id"`
	Confidence float64 `json:"confidence"`
}

func (q *Queries) BulkAutoApproveMatches(ctx context.Context, arg BulkAutoApproveMatchesParams) error {
	_, err := q.db.ExecContext(ctx, bulkAutoApproveMatches, arg.ImportID, arg.Confidence)
	return err
}

const countMatchesByStatus = `-- name: CountMatchesByStatus :many
SELECT status, COUNT(*) as count
FROM price_import_matches
WHERE import_id = ?
GROUP BY status
`

type CountMatchesByStatusRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

func (q *Queries) CountMatchesByStatus(ctx context.Context, importID string) ([]CountMatchesByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, countMatchesByStatus, importID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountMatchesByStatusRow{}
	for rows.Next() {
		var i CountMatchesByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createPriceImport = `-- name: CreatePriceImport :one
INSERT INTO price_imports (id, filename, status, total_rows)
VALUES (?, ?, ?, ?)
RETURNING id, filename, status, total_rows, matched_rows, error_message, created_at, applied_at
`

type CreatePriceImportParams struct {
	ID        string `json:"id"`
	Filename  string `json:"filename"`
	Status    string `json:"status"`
	TotalRows int64  `json:"total_rows"`
}

func (q *Queries) CreatePriceImport(ctx context.Context, arg CreatePriceImportParams) (PriceImport, error) {
	row := q.db.QueryRowContext(ctx, createPriceImport,
		arg.ID,
		arg.Filename,
		arg.Status,
		arg.TotalRows,
	)
	var i PriceImport
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Status,
		&i.TotalRows,
		&i.MatchedRows,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.AppliedAt,
	)
	return i, err
}

const createPriceImportMatch = `-- name: CreatePriceImportMatch :one
INSERT INTO price_import_matches (
    import_id, row_number, source_name, source_unit, source_price,
    matched_template_id, confidence, match_reason, status
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, import_id, row_number, source_name, source_unit, source_price, matched_template_id, confidence, match_reason, status, new_name, created_at
`

type CreatePriceImportMatchParams struct {
	ImportID          string         `json:"import_id"`
	RowNumber         int64          `json:"row_number"`
	SourceName        string         `json:"source_name"`
	SourceUnit        sql.NullString `json:"source_unit"`
	SourcePrice       float64        `json:"source_price"`
	MatchedTemplateID sql.NullInt64  `json:"matched_template_id"`
	Confidence        float64        `json:"confidence"`
	MatchReason       sql.NullString `json:"match_reason"`
	Status            string         `json:"status"`
}

func (q *Queries) CreatePriceImportMatch(ctx context.Context, arg CreatePriceImportMatchParams) (PriceImportMatch, error) {
	row := q.db.QueryRowContext(ctx, createPriceImportMatch,
		arg.ImportID,
		arg.RowNumber,
		arg.SourceName,
		arg.SourceUnit,
		arg.SourcePrice,
		arg.MatchedTemplateID,
		arg.Confidence,
		arg.MatchReason,
		arg.Status,
	)
	var i PriceImportMatch
	err := row.Scan(
		&i.ID,
		&i.ImportID,
		&i.RowNumber,
		&i.SourceName,
		&i.SourceUnit,
		&i.SourcePrice,
		&i.MatchedTemplateID,
		&i.Confidence,
		&i.MatchReason,
		&i.Status,
		&i.NewName,
		&i.CreatedAt,
	)
	return i, err
}

const getPriceImport = `-- name: GetPriceImport :one
SELECT id, filename, status, total_rows, matched_rows, error_message, created_at, applied_at FROM price_imports WHERE id = ?
`

func (q *Queries) GetPriceImport(ctx context.Context, id string) (PriceImport, error) {
	row := q.db.QueryRowContext(ctx, getPriceImport, id)
	var i PriceImport
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Status,
		&i.TotalRows,
		&i.MatchedRows,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.AppliedAt,
	)
	return i, err
}

const listApprovedMatches = `-- name: ListApprovedMatches :many
SELECT
    m.id, m.import_id, m.row_number, m.source_name, m.source_unit, m.source_price, m.matched_template_id, m.confidence, m.match_reason, m.status, m.new_name, m.created_at,
    t.name as template_name
FROM price_import_matches m
JOIN item_templates t ON m.matched_template_id = t.id
WHERE m.import_id = ? AND m.status IN ('approved', 'auto_approved')
`

type ListApprovedMatchesRow struct {
	ID                int64          `json:"id"`
	ImportID          string         `json:"import_id"`
	RowNumber         int64          `json:"row_number"`
	SourceName        string         `json:"source_name"`
	SourceUnit        sql.NullString `json:"source_unit"`
	SourcePrice       float64        `json:"source_price"`
	MatchedTemplateID sql.NullInt64  `json:"matched_template_id"`
	Confidence        float64        `json:"confidence"`
	MatchReason       sql.NullString `json:"match_reason"`
	Status            string         `json:"status"`
	NewName           sql.NullString `json:"new_name"`
	CreatedAt         string         `json:"created_at"`
	TemplateName      string         `json:"template_name"`
}

func (q *Queries) ListApprovedMatches(ctx context.Context, importID string) ([]ListApprovedMatchesRow, error) {
	rows, err := q.db.QueryContext(ctx, listApprovedMatches, importID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListApprovedMatchesRow{}
	for rows.Next() {
		var i ListApprovedMatchesRow
		if err := rows.Scan(
			&i.ID,
			&i.ImportID,
			&i.RowNumber,
			&i.SourceName,
			&i.SourceUnit,
			&i.SourcePrice,
			&i.MatchedTemplateID,
			&i.Confidence,
			&i.MatchReason,
			&i.Status,
			&i.NewName,
			&i.CreatedAt,
			&i.TemplateName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatchesByImport = `-- name: ListMatchesByImport :many
SELECT
    m.id, m.import_id, m.row_number, m.source_name, m.source_unit, m.source_price, m.matched_template_id, m.confidence, m.match_reason, m.status, m.new_name, m.created_at,
    t.name as template_name,
    t.default_unit as template_unit,
    t.default_price as template_price
FROM price_import_matches m
LEFT JOIN item_templates t ON m.matched_template_id = t.id
WHERE m.import_id = ?
ORDER BY m.confidence DESC, m.row_number
`

type ListMatchesByImportRow struct {
	ID                int64           `json:"id"`
	ImportID          string          `json:"import_id"`
	RowNumber         int64           `json:"row_number"`
	SourceName        string          `json:"source_name"`
	SourceUnit        sql.NullString  `json:"source_unit"`
	SourcePrice       float64         `json:"source_price"`
	MatchedTemplateID sql.NullInt64   `json:"matched_template_id"`
	Confidence        float64         `json:"confidence"`
	MatchReason       sql.NullString  `json:"match_reason"`
	Status            string          `json:"status"`
	NewName           sql.NullString  `json:"new_name"`
	CreatedAt         string          `json:"created_at"`
	TemplateName      sql.NullString  `json:"template_name"`
	TemplateUnit      sql.NullString  `json:"template_unit"`
	TemplatePrice     sql.NullFloat64 `json:"template_price"`
}

func (q *Queries) ListMatchesByImport(ctx context.Context, importID string) ([]ListMatchesByImportRow, error) {
	rows, err := q.db.QueryContext(ctx, listMatchesByImport, importID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMatchesByImportRow{}
	for rows.Next() {
		var i ListMatchesByImportRow
		if err := rows.Scan(
			&i.ID,
			&i.ImportID,
			&i.RowNumber,
			&i.SourceName,
			&i.SourceUnit,
			&i.SourcePrice,
			&i.MatchedTemplateID,
			&i.Confidence,
			&i.MatchReason,
			&i.Status,
			&i.NewName,
			&i.CreatedAt,
			&i.TemplateName,
			&i.TemplateUnit,
			&i.TemplatePrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPriceImports = `-- name: ListPriceImports :many
SELECT id, filename, status, total_rows, matched_rows, error_message, created_at, applied_at FROM price_imports
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListPriceImportsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListPriceImports(ctx context.Context, arg ListPriceImportsParams) ([]PriceImport, error) {
	rows, err := q.db.QueryContext(ctx, listPriceImports, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PriceImport{}
	for rows.Next() {
		var i PriceImport
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Status,
			&i.TotalRows,
			&i.MatchedRows,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.AppliedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedItems = `-- name: ListUnmatchedItems :many
SELECT id, import_id, row_number, source_name, source_unit, source_price, matched_template_id, confidence, match_reason, status, new_name, created_at FROM price_import_matches
WHERE import_id = ? AND matched_template_id IS NULL AND status = 'pending'
ORDER BY row_number
`

func (q *Queries) ListUnmatchedItems(ctx context.Context, importID string) ([]PriceImportMatch, error) {
	rows, err := q.db.QueryContext(ctx, listUnmatchedItems, importID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PriceImportMatch{}
	for rows.Next() {
		var i PriceImportMatch
		if err := rows.Scan(
			&i.ID,
			&i.ImportID,
			&i.RowNumber,
			&i.SourceName,
			&i.SourceUnit,
			&i.SourcePrice,
			&i.MatchedTemplateID,
			&i.Confidence,
			&i.MatchReason,
			&i.Status,
			&i.NewName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMatchAsCreated = `-- name: MarkMatchAsCreated :one
UPDATE price_import_matches
SET status = 'created', matched_template_id = ?
WHERE id = ?
RETURNING id, import_id, row_number, source_name, source_unit, source_price, matched_template_id, confidence, match_reason, status, new_name, created_at
`

type MarkMatchAsCreatedParams struct {
	MatchedTemplateID sql.NullInt64 `json:"matched_template_id"`
	ID                int64         `json:"id"`
}

func (q *Queries) MarkMatchAsCreated(ctx context.Context, arg MarkMatchAsCreatedParams) (PriceImportMatch, error) {
	row := q.db.QueryRowContext(ctx, markMatchAsCreated, arg.MatchedTemplateID, arg.ID)
	var i PriceImportMatch
	err := row.Scan(
		&i.ID,
		&i.ImportID,
		&i.RowNumber,
		&i.SourceName,
		&i.SourceUnit,
		&i.SourcePrice,
		&i.MatchedTemplateID,
		&i.Confidence,
		&i.MatchReason,
		&i.Status,
		&i.NewName,
		&i.CreatedAt,
	)
	return i, err
}

const markPriceImportApplied = `-- name: MarkPriceImportApplied :one
UPDATE price_imports
SET status = 'applied', applied_at = datetime('now')
WHERE id = ?
RETURNING id, filename, status, total_rows, matched_rows, error_message, created_at, applied_at
`

func (q *Queries) MarkPriceImportApplied(ctx context.Context, id string) (PriceImport, error) {
	row := q.db.QueryRowContext(ctx, markPriceImportApplied, id)
	var i PriceImport
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Status,
		&i.TotalRows,
		&i.MatchedRows,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.AppliedAt,
	)
	return i, err
}

const updateMatchStatus = `-- name: UpdateMatchStatus :one
UPDATE price_import_matches SET status = ? WHERE id = ? RETURNING id, import_id, row_number, source_name, source_unit, source_price, matched_template_id, confidence, match_reason, status, new_name, created_at
`

type UpdateMatchStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateMatchStatus(ctx context.Context, arg UpdateMatchStatusParams) (PriceImportMatch, error) {
	row := q.db.QueryRowContext(ctx, updateMatchStatus, arg.Status, arg.ID)
	var i PriceImportMatch
	err := row.Scan(
		&i.ID,
		&i.ImportID,
		&i.RowNumber,
		&i.SourceName,
		&i.SourceUnit,
		&i.SourcePrice,
		&i.MatchedTemplateID,
		&i.Confidence,
		&i.MatchReason,
		&i.Status,
		&i.NewName,
		&i.CreatedAt,
	)
	return i, err
}

const updateMatchWithName = `-- name: UpdateMatchWithName :one
UPDATE price_import_matches
SET status = ?, new_name = ?
WHERE id = ?
RETURNING id, import_id, row_number, source_name, source_unit, source_price, matched_template_id, confidence, match_reason, status, new_name, created_at
`

type UpdateMatchWithNameParams struct {
	Status  string         `json:"status"`
	NewName sql.NullString `json:"new_name"`
	ID      int64          `json:"id"`
}

func (q *Queries) UpdateMatchWithName(ctx context.Context, arg UpdateMatchWithNameParams) (PriceImportMatch, error) {
	row := q.db.QueryRowContext(ctx, updateMatchWithName, arg.Status, arg.NewName, arg.ID)
	var i PriceImportMatch
	err := row.Scan(
		&i.ID,
		&i.ImportID,
		&i.RowNumber,
		&i.SourceName,
		&i.SourceUnit,
		&i.SourcePrice,
		&i.MatchedTemplateID,
		&i.Confidence,
		&i.MatchReason,
		&i.Status,
		&i.NewName,
		&i.CreatedAt,
	)
	return i, err
}

const updatePriceImportStatus = `-- name: UpdatePriceImportStatus :one
UPDATE price_imports
SET status = ?, matched_rows = ?, error_message = ?, total_rows = ?
WHERE id = ?
RETURNING id, filename, status, total_rows, matched_rows, error_message, created_at, applied_at
`

type UpdatePriceImportStatusParams struct {
	Status       string         `json:"status"`
	MatchedRows  int64          `json:"matched_rows"`
	ErrorMessage sql.NullString `json:"error_message"`
	TotalRows    int64          `json:"total_rows"`
	ID           string         `json:"id"`
}

func (q *Queries) UpdatePriceImportStatus(ctx context.Context, arg UpdatePriceImportStatusParams) (PriceImport, error) {
	row := q.db.QueryRowContext(ctx, updatePriceImportStatus,
		arg.Status,
		arg.MatchedRows,
		arg.ErrorMessage,
		arg.TotalRows,
		arg.ID,
	)
	var i PriceImport
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Status,
		&i.TotalRows,
		&i.MatchedRows,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.AppliedAt,
	)
	return i, err
}
